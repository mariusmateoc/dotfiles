#!/bin/bash

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Simple calculator
calc() {
    local result="";
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')";
    #                       â””â”€ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
            -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
            -e 's/0*$//;s/\.$//';  # remove trailing zeros
    else
        printf "$result";
    fi;
    printf "\n";
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Who is using the laptop's iSight camera?

camerausedby() {
    echo "Checking to see who is using the iSight cameraâ€¦ ðŸ“·"
    usedby=$(lsof | grep -w "AppleCamera\|USBVDC\|iSight" | awk '{printf $2"\n"}' | xargs ps)
    echo -e "Recent camera uses:\n$usedby"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# cd into whatever is the forefront Finder window.

cdf() {  # short for cdfinder
    cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Copy w/ progress

cp_p () {
    rsync -WavP --human-readable --progress $1 $2
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Create data URI from a file.

datauri() {

    local mimeType=""

    if [ -f "$1" ]; then
        mimeType=$(file -b --mime-type "$1")
        #                â””â”€ do not prepend the filename to the output

        if [[ $mimeType == text/* ]]; then
            mimeType="$mimeType;charset=utf-8"
        fi

        printf "data:%s;base64,%s" \
                    "$mimeType" \
                    "$(openssl base64 -in "$1" | tr -d "\n")"
    else
        printf "%s is not a file.\n" "$1"
    fi

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Delete files that match a certain pattern from the current directory.

delete-files() {
    local q="${1:-*.DS_Store}"
    find . -type f -name "$q" -ls -delete
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Copy template for design project in projects directory

design() {
    NORMAL=`echo "\033[m"`
    RED_TEXT=`echo "\033[31m"`

    if [ -z "$2" ]; then
        cp_p ~/Dropbox/Resources/Templates/Design/ ~/Dropbox/Work/Projects/"$1"
    else
        echo -e "${RED_TEXT}ATTENTION: ${NORMAL}Provide only the project name as single argument."
    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# All the dig info

digga() {
    dig +nocmd "$1" any +multiline +noall +answer
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Execute Vim macro

evm() {

    local numberOfTimes="${*: -1}"
    local files

    if [[ "$numberOfTimes" =~ ^[0-9]+$ ]]; then
        files=("${@:1:$#-1}")
    else
        numberOfTimes="1"
        files=("$@")
    fi

    for file in "${files[@]}"; do
        printf "* %s\n" "$file"
        vim -c "norm! $numberOfTimes@q" -c "wq" "$file"
    done

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc

extract() {
    if [ -f "$1" ] ; then
        local filename=$(basename "$1")
        local foldername="${filename%%.*}"
        local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
        local didfolderexist=false
        if [ -d "$foldername" ]; then
        didfolderexist=true
        read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
        echo
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            return
        fi
        fi
        mkdir -p "$foldername" && cd "$foldername"
        case $1 in
        *.tar.bz2) tar xjf "$fullpath" ;;
        *.tar.gz) tar xzf "$fullpath" ;;
        *.tar.xz) tar Jxvf "$fullpath" ;;
        *.tar.Z) tar xzf "$fullpath" ;;
        *.tar) tar xf "$fullpath" ;;
        *.taz) tar xzf "$fullpath" ;;
        *.tb2) tar xjf "$fullpath" ;;
        *.tbz) tar xjf "$fullpath" ;;
        *.tbz2) tar xjf "$fullpath" ;;
        *.tgz) tar xzf "$fullpath" ;;
        *.txz) tar Jxvf "$fullpath" ;;
        *.zip) unzip "$fullpath" ;;
        *.rar) unar e "$fullpath" ;;
        *) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Create a git.io short URL

gitio() {
    if [ -z "${1}" -o -z "${2}" ]; then
        echo "Usage: \`gitio slug url\`";
        return 1;
    fi;
    curl -i http://git.io/ -F "url=${2}" -F "code=${1}";
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Get gzip information (gzipped file size + reduction size).

gz() {

    declare -i gzippedSize=0
    declare -i originalSize=0

    if [ -f "$1" ]; then
        if [ -s "$1" ]; then

            originalSize=$( wc -c < "$1" )
            printf "\n original size:   %12s\n" "$(hrfs "$originalSize")"

            gzippedSize=$( gzip -c "$1" | wc -c )
            printf " gzipped size:    %12s\n" "$(hrfs "$gzippedSize")"

            printf " â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            printf " reduction:       %12s [%s%%]\n\n" \
                        "$( hrfs $((originalSize - gzippedSize)) )" \
                        "$( printf "%s" "$originalSize $gzippedSize" | \
                            awk '{ printf "%.1f", 100 - $2 * 100 / $1 }' | \
                            sed -e "s/0*$//;s/\.$//" )"
                            #              â””â”€ remove tailing zeros

        else
            printf "\"%s\" is empty.\n" "$1"
        fi
    else
        printf "\"%s\" is not a file.\n" "$1"
    fi

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Human readable file size
# (because `du -h` doesn't cut it for me).

hrfs() {

    printf "%s" "$1" |
    awk '{
            i = 1;
            split("B KB MB GB TB PB EB ZB YB WTFB", v);
            value = $1;

            # confirm that the input is a number
            if ( value + .0 == value ) {

                while ( value >= 1024 ) {
                    value/=1024;
                    i++;
                }

                if ( value == int(value) ) {
                    printf "%d %s", value, v[i]
                } else {
                    printf "%.1f %s", value, v[i]
                }

            }
        }' |
    sed -e ":l" \
        -e "s/\([0-9]\)\([0-9]\{3\}\)/\1,\2/; t l"
    #    â””â”€ add thousands separator
    #       (changes "1023.2 KB" to "1,023.2 KB")
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Syntax-highlight JSON strings or files

json() {
    if [ -p /dev/stdin ]; then
        # piping, e.g. `echo '{"foo":42}' | json`
        python -mjson.tool | pygmentize -l javascript
    else
        # e.g. `json '{"foo":42}'`
        python -mjson.tool <<< "$*" | pygmentize -l javascript
    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Create new directories and enter the first one.

mkd() {
    if [ -n "$*" ]; then

        mkdir -p "$@"
        #      â””â”€ make parent directories if needed

        cd "$@" \
            || exit 1

    fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Process phone photo.

ppp() {

    # Check if ImageMagick's convert command-line tool is installed.

    if ! command -v "convert" $> /dev/null; then
        printf "Please install ImageMagick's 'convert' command-line tool!"
        exit;
    fi

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    declare option="$1"
    declare photo="${2:-*.jpg}"
    declare geometry="${3:-50%}"

    if [ "$option" != "clean" ] &&
       [ "$option" != "resize" ]; then
        option="resize"
        photo="${1:-*.jpg}"
        geometry="${2:-50%}"
    fi

    if [[ "$(echo "${photo##*.}" | tr '[:upper:]' '[:lower:]')" != "png" ]]; then
        newPhotoName="${photo%.*}.png"
    else
        newPhotoName="_${photo%.*}.png"
    fi

    if [ "$option" == "resize" ]; then
        convert "$photo" \
            -colorspace RGB \
            +sigmoidal-contrast 11.6933 \
            -define filter:filter=Sinc \
            -define filter:window=Jinc \
            -define filter:lobes=3 \
            -sigmoidal-contrast 11.6933 \
            -colorspace sRGB \
            -background transparent \
            -gravity center \
            -resize "$geometry" \
            +append \
            "$newPhotoName" \
        && printf "* %s (%s)\n" \
            "$newPhotoName" \
            "$geometry"

        return
    fi

    convert "$photo" \
        -morphology Convolve DoG:10,10,0 \
        -negate \
        -normalize \
        -blur 0x1 \
        -channel RBG \
        -level 10%,91%,0.1 \
        "$newPhotoName" \
        && printf "* %s\n" "$newPhotoName"

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search history.

qh() {
    #           â”Œâ”€ enable colors for pipe
    #           â”‚  ("--color=auto" enables colors only if
    #           â”‚  the output is in the terminal)
    grep --color=always "$*" "$HISTFILE" |       less -RX
    # display ANSI color escape sequences in raw form â”€â”˜â”‚
    #       don't clear the screen after quitting less â”€â”˜
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search for text within the current directory.

qt() {
    grep -ir --color=always "$*" --exclude-dir=".git" --exclude-dir="node_modules" . | less -RX
    #     â”‚â””â”€ search all files under each directory, recursively
    #     â””â”€ ignore case
}
